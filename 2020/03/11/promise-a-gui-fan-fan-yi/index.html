<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Promise A+ 规范翻译及个人总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="翻译自原文链接， 本文格式基本参照原文， 对于带有标号的术语，请参考对应标号的解释。 英语水平所限， 看不懂的可以阅读原文。 正文 一个针对实现者，实现健全的，可操作的 JavaScript promise 的开放的规范。  一个 promise 代表了一个异步操作的最终的结果。与 promise 互动的主要方法是通过它的 then 方法， then 方法用来注册接收 promise 的终值或者为">
<meta property="og:type" content="article">
<meta property="og:title" content="Promise A+ 规范翻译及个人总结">
<meta property="og:url" content="http://cumbermiao.github.io/blog/2020/03/11/promise-a-gui-fan-fan-yi/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="翻译自原文链接， 本文格式基本参照原文， 对于带有标号的术语，请参考对应标号的解释。 英语水平所限， 看不懂的可以阅读原文。 正文 一个针对实现者，实现健全的，可操作的 JavaScript promise 的开放的规范。  一个 promise 代表了一个异步操作的最终的结果。与 promise 互动的主要方法是通过它的 then 方法， then 方法用来注册接收 promise 的终值或者为">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-03-11T14:23:15.000Z">
<meta property="article:modified_time" content="2020-04-16T14:12:22.521Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="promise">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://cumbermiao.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-promise-a-gui-fan-fan-yi" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/11/promise-a-gui-fan-fan-yi/" class="article-date">
  <time datetime="2020-03-11T14:23:15.000Z" itemprop="datePublished">2020-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Promise A+ 规范翻译及个人总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>翻译自<a href="https://promisesaplus.com/" target="_blank" rel="noopener">原文链接</a>， 本文格式基本参照原文， 对于带有标号的术语，请参考对应标号的解释。<br> 英语水平所限， 看不懂的可以阅读原文。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><blockquote>
<p>一个针对实现者，实现健全的，可操作的 JavaScript promise 的开放的规范。</p>
</blockquote>
<p>一个 <em>promise</em> 代表了一个异步操作的最终的结果。与 promise 互动的主要方法是通过它的 <code>then</code> 方法， <code>then</code> 方法用来注册接收 promise 的终值或者为何该 promise 为什么无法完成的 reason 的回调。</p>
<p>此规范详细说明了 <code>then</code> 方法的行为，提供一个所有符合 Promises/A+ 规范实现的 promise 都可以依赖的可互操作的基础。 因此， 此规范需要考虑到非常稳定。虽然 Promises/A+ 组织可能会偶尔修改此规范， 对其进行一些向后兼容的小修改以解决新发现的问题，只有在进过仔细考虑、讨论和测试之后我们才会集成大型的或向后不兼容的变更。</p>
<p>从历史上看，Promises / A +阐明了早期Promises / A提案的行为条款，将其扩展为涵盖实际行为，并省略了未指定或有问题的部分。</p>
<p>最后， Promises/A+ 规范的核心不涉及如何创建、完成或者拒绝 promises ， 而是聚焦于提供可互操作的<code>then</code>方法。未来在配套规范中的工作可能会涉及这些主题。</p>
<h2 id="1-术语"><a href="#1-术语" class="headerlink" title="1. 术语"></a>1. 术语</h2><p>1.1.    “promise” 是一个带有符合本规范中<code>then</code> 方法的行为的对象或者函数。<br>1.2.    “thenable” 是一个定义 <code>then</code> 方法的对象或者函数。<br>1.3.    “value” 是任意合法的 JavaScript 值， 包含 <code>undefined</code>, <code>thenable</code>,<code>promise</code>。<br>1.4.    “exception” 是通过 <code>throw</code> 声明语句抛出来的值。<br>1.5.    “reason” 是表明为何一个 promise 被拒绝的值。</p>
<h2 id="2-要求"><a href="#2-要求" class="headerlink" title="2.  要求"></a>2.  要求</h2><h3 id="2-1-Promise-状态"><a href="#2-1-Promise-状态" class="headerlink" title="2.1 Promise 状态"></a>2.1 Promise 状态</h3><p>一个 promise 必须处于以下三个状态之中： pending， fulfilled， rejected 。</p>
<p>2.1.1.  当处于 pending 状态<br>        2.1.1.1.    promise 可以转变为 fulfilled 或者 rejected 状态。</p>
<p>2.1.2.  当处于 fulfilled 状态<br>        2.1.2.1.    promise 无法转变成其他状态。<br>        2.1.2.2.    promise 必须要有一个无法改变的 value。</p>
<p>2.1.3.  当处于 rejected 状态<br>        2.1.3.1.    promise 无法转变成其他状态。<br>        2.1.3.2.    promise 必须要有一个无法改变的 value。</p>
<p>在此处， 无法改变意味着不可变， 类似 <code>===</code> 全等， 但不意味深层次的不变。（译者： 可以理解为指针不变即可。）</p>
<h3 id="2-2-then-方法"><a href="#2-2-then-方法" class="headerlink" title="2.2 then 方法"></a>2.2 <code>then</code> 方法</h3><p>一个 promise 必须提供一个 <code>then</code> 方法去获取它当前或者最终的 value 或 reason 。<br>promise 的<code>then</code> 方法接收两个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<p>2.2.1.  <code>onFulfilled</code> 和 <code>onRejected</code> 参数都是可选的<br>        2.2.1.1.     如果 <code>onFulfilled</code> 不是函数， 它将会被忽略。<br>        2.2.1.2.     如果 <code>onRejected</code> 不是函数， 它将会被忽略。</p>
<p>2.2.2.  如果 <code>onFulfilled</code> 是函数<br>        2.2.2.1.    在 <code>promise</code> 处于<code>fulfilled</code>状态之后， 它将被调用， 其第一个参数为 <code>promise</code> 的 value。<br>        2.2.2.2.    在 <code>promise</code> 处于<code>fulfilled</code>状态之前， 它无法被调用。<br>        2.2.2.3.    它只能被调用一次。</p>
<p>2.2.3.  如果 <code>onRejected</code> 是函数<br>         2.2.3.1.    在 <code>promise</code> 处于<code>rejected</code>状态之后， 它将被调用， 其第一个参数为 <code>promise</code> 的 reason 。<br>        2.2.3.2.    在 <code>promise</code> 处于<code>rejected</code>状态之前， 它无法被调用。<br>        2.2.3.3.    它只能被调用一次。</p>
<p>2.2.4.  <code>onFulfilled</code> 和 <code>onRejected</code> 函数只有当 <code>execution context stack</code> (执行栈?执行上下文?) 只包含 <code>platform code</code>[3.1] 。</p>
<p>2.2.5.  <code>onFulfilled</code> 和 <code>onRejected</code>  必须以函数的方式调用(例如， 没有 <code>this</code>)[3.2]</p>
<p>2.2.6.  <code>then</code> 可能在同一个 promise 中调用多次<br>        2.2.6.1.    当 promise 处于 <code>fulfilled</code> 状态， 所有各自的<code>onFulfilled</code>回调必须按照它们的<code>then</code> 的原始顺序执行。<br>        2.2.6.2.    当 promise 处于 <code>rejected</code> 状态,  所有各自的<code>onRejected</code>回调必须按照它们的<code>then</code>的原始顺序执行。</p>
<p>2.2.7.  <code>then</code> 需要返回一个 promise [3.3]</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>

<p> 2.2.7.1.    如果 <code>onFulfilled</code> 或者<code>onRejected</code> 之一返回一个 value <code>x</code>,  执行 promise resolution procedure <code>[[Resolve]](promise2, x)</code>。<br> 2.2.7.2.    如果 <code>onFulfilled</code> 或者<code>onRejected</code> 之一抛出一个 exception <code>e</code> , <code>promise2</code> 必须被 rejected 并使用 <code>e</code> 作为 reason。<br>2.2.7.3.    如果 <code>onFulfilled</code> 不是一个函数， 并且 <code>promise1</code> 处于 <code>fulfilled</code> 状态， <code>promise2</code> 必须被置为 <code>fulfilled</code> 状态， 并且使用 <code>promise1</code> 的 <code>value</code> 作为 <code>promise2</code> 的 <code>value</code>。<br>2.2.7.4.    如果 <code>onRejected</code>不是一个函数， 并且 <code>promise1</code> 处于 <code>rejected</code> 状态， <code>promise2</code> 必须被置为 <code>rejected</code> 状态， 并且使用 <code>promise1</code> 的 <code>reason</code> 作为 <code>promise2</code> 的 <code>reason</code>。</p>
<h3 id="2-3-The-Promise-Resolution-Procedure-Promise-解决程序"><a href="#2-3-The-Promise-Resolution-Procedure-Promise-解决程序" class="headerlink" title="2.3 The Promise Resolution Procedure (Promise 解决程序)"></a>2.3 The Promise Resolution Procedure (Promise 解决程序)</h3><p>The promise resolution procedure 是一个抽象操作， 接受一个 promise 和 一个 value 作为输入，表示为 <code>[[Resolve]](promise, x)</code> 。 如果 <code>x</code> 是一个 thenable , 假设 <code>x</code> 的行为至少在某种程度上与 promise 类似，它将会尝试使用 <code>x</code> 的状态作为 <code>promise</code> 的状态。<br>否则， 它将会使用 value <code>x</code> 将 <code>promise</code> 置为 <code>fulfilled</code> 状态。</p>
<p>只要它们暴露一个基于 Promises/A+规范实现的 <code>then</code> 方法， 对于 thenables 的处理就允许 promise 互操作的实现。 它也允许 Promises/A+ 同化使用 reasonable <code>then</code> 方式的不合格的实现。</p>
<p>执行 <code>[[Resolve]](promise, x)</code> 会执行以下步骤：</p>
<p>2.3.1.  如果 <code>promise</code> 和 <code>x</code> 指向同一个对象， <code>promise</code> 使用 <code>TypeError</code> 作为 reason， 并置为 <code>rejected</code> 状态。 (new Promise 里面必须调用 resolve 或者 reject， 如何将 promise 和 x 指向同一个对象？)</p>
<p>2.3.2.  如果 <code>x</code> 是一个 promise， 采用<code>x</code>的状态[3.4]。<br>        2.3.2.1.    如果 <code>x</code> 处于 pending 状态， <code>promise</code> 必须处于 pending<br>        状态直到 <code>x</code> 状态改变。<br>         2.3.2.2.    如果 <code>x</code> 处于 fulfilled 状态, 使用 <code>x</code> 的 value 将<code>promise</code> 置为 fulfilled 状态。<br>        2.3.2.3.     如果 <code>x</code> 处于 rejected 状态, 使用 <code>x</code> 的 reason 将<code>promise</code> 置为 rejected 状态。</p>
<p>2.3.3.  如果 <code>x</code> 是一个对象或者函数<br>        2.3.3.1.    让 <code>then</code> 变成 <code>x.then</code>. [3.5]<br>        2.3.3.2.    如果查找 <code>x.then</code> 属性造成抛出异常 <code>e</code>, 将 promise 置为<code>rejected</code> 状态并使用 <code>e</code> 作为 reason。<br>        2.3.3.3.    如果 <code>then</code> 是一个函数， 会调用该函数，并使用使用 <code>x</code>作为 this 。该函数有两参数， 第一个参数为 <code>resolvePromise</code>, 第二个参数为<code>rejectPromise</code><br>                    2.3.3.3.1.  如果 <code>resolvePromise</code> 使用 value <code>y</code> 调用， 执行 <code>[[Resolve]](promise, y)</code>。<br>                    2.3.3.3.2.  如果 <code>rejectPromise</code> 使用 reason <code>r</code> 调用， 使用 <code>r</code> 将 promise 状态置为 <code>rejected</code>。<br>                    2.3.3.3.3.  如果 <code>resolvePromise</code> 和<code>rejectPromise</code>都被调用， 或者多次调用了相同参数， 第一次调用会执行， 其他的会被忽略。<br>                    2.3.3.3.4.  如果执行的 then 抛出异常 <code>e</code><br>                                    2.3.3.3.4.1.    如果  <code>resolvePromise</code> 或<code>rejectPromise</code>被调用， 忽略它。<br>                                    2.3.3.3.4.2.    使用 <code>e</code> 将 promise 置为 <code>rejected</code> 状态。<br>        2.3.3.4.    如果 then  不是函数， 使用 <code>x</code> 将 promise 置为 <code>fulfilled</code> 状态。</p>
<p> 2.3.4.     如果<code>x</code>不是对象或者函数， 使用 <code>x</code> 将 promise 置为 <code>fulfilled</code> 状态。</p>
<p> 如果 promise resolved 了一个 thenable 对象， 该 thenable 对象参与到了循环的 thenable 链， 例如 <code>[[Resolve]](promise, thenable)</code> 的递归性质最终会导致 <code>[[Resolve]](promise, thenable)</code> 被再次调用， 最终会导致无限递归。我们鼓励检测这样的递归并且使用一个带有信息的<code>TypeError</code> reason 将 promise 置为<code>rejected</code>状态， 但此实现不是必须的。</p>
<h3 id="3-Notes"><a href="#3-Notes" class="headerlink" title="3. Notes"></a>3. Notes</h3><p> 3.1.    此处的 “platform code”代表引擎、环境和 promise 实现的代码。实际上， 这个要求确保在事件循环中轮到 then 调用之后，<code>onFulfilled</code> 和 <code>onRejected</code> 能在最新的执行栈下异步执行。这个可以通过使用宏任务方法例如 <code>setTimeout</code> <code>setImmediate</code> 或者 微任务方法例如<code>MutationObserver</code> <code>process.nextTick</code> 实现。由于 promise 实现被认为是“platform code”, 它自己有可能会包含一个任务调度队列或者 “trampoline” , 在这个队列里面调用处理程序。</p>
<p> 3.2.   就是说， 在严格模式下 <code>this</code> 在里面会指向 undefined , 在宽松模式下， 它将指向全局对象。</p>
<p> 3.3.   如果实现满足了所有要求， 实现会允许出现 <code>promise2===promise1</code> 的情况。 每个实现应该表明是否会产生<code>promise2 === promise1</code>的现象， 以及在什么情况下会出现该情况。</p>
<p> 3.4.   通常来说， 只有当 <code>x</code> 来自当前的实现时才能知道 <code>x</code> 是一个真的 promise 。此条款允许特定实现方式的使用可以采用已知符合的 promise 状态。(译者： 使用 x 的状态来代替外层 promise 的状态)</p>
<p> 3.5.   程序首先存储对 <code>x.then</code> 的应用， 然后测试该引用， 然后调用该引用， 防止多次访问 <code>x.then</code> 属性。 此类预防措施对于确保访问者属性的一致性非常重要，因为访问者属性的值在两次检索之间可能会发生变化。</p>
<p> 3.6.   实现中不应该对 thenable 链的深度设置任意限制， 认为当超过该限制时递归就是无限的。 只有真正的循环才会导致 TypeError 。如果遇到多个不同的 thenables 组成的链， 递归永远是正确的行为。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>需要重点注意的是 <a href="promise,x">[Resolve]</a> 对于 x 不同类型执行不同流程。</p>
</blockquote>
<ul>
<li>Promises/A+ 规范的核心在于提供 then 方法。</li>
<li>promise 是一个带有符合规范的<code>then</code>方法的对象或者函数。</li>
<li>promise 有三个状态: <code>pending</code>, <code>fulfilled</code>,<code>rejected</code> ， 状态一旦改变就无法更改。</li>
<li>promise.then(onFulfilled,onRejected) 中 onFulfilled，onRejected 如果不是函数会被忽略。</li>
<li>then 方法返回一个 promise。</li>
<li>promise2 = promise1.then(onFulfilled, onRejected) 中根据 onFulfilled，onRejected 返回的 value ， reason 更改 promise2 的状态并使用对应的 value， reason 作为返回值。</li>
<li><a href="promise,x">[Resolve]</a> <ul>
<li>如果 x 是一个 promise ， 使用 x 的状态代替 promise 的状态；</li>
<li>如果 x 不是一个对象或者函数， 使用 x 将 promise 置为 fullfiled 状态。</li>
<li>如果 x 是一个对象或者函数， <ul>
<li>如果 x.then 不是函数， 使用 x 将 promise 置为 fulfilled 状态。</li>
<li>尝试查找 x.then， 如果查找报错使用该错误 rejected， </li>
<li>如果 x.then 是一个函数，会使用 x 作为 this 调用 x.then ，<ul>
<li>x.then(resolvePromise, rejectPromise), x.then 接受所示两个参数， 如果调用 resolvePromise(y) 则执行 <a href="promise,y">[Resolve]</a> ；如果调用 rejectPromise(r), 使用 reason r 将 promise 状态置为 rejected 。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2020/03/11/promise-a-gui-fan-fan-yi/" data-id="ck92ufa2k001tzcoucqgd6ftz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/promise/" rel="tag">promise</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2020/03/15/react-dom-diff/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          React DOM Diff
        
      </div>
    </a>
  
  
    <a href="/blog/2020/03/07/vue-ssr-ti-yan/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Vue SSR 体验</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Array/" rel="tag">Array</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Sparse-Array/" rel="tag">Sparse Array</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/diff/" rel="tag">diff</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fiber/" rel="tag">fiber</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/hooks/" rel="tag">hooks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/promise/" rel="tag">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/sort/" rel="tag">sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/string/" rel="tag">string</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%97%AD%E5%8C%85/" rel="tag">闭包</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Array/" style="font-size: 13.33px;">Array</a> <a href="/blog/tags/Sparse-Array/" style="font-size: 10px;">Sparse Array</a> <a href="/blog/tags/diff/" style="font-size: 10px;">diff</a> <a href="/blog/tags/fiber/" style="font-size: 10px;">fiber</a> <a href="/blog/tags/git/" style="font-size: 10px;">git</a> <a href="/blog/tags/hooks/" style="font-size: 10px;">hooks</a> <a href="/blog/tags/js/" style="font-size: 20px;">js</a> <a href="/blog/tags/promise/" style="font-size: 10px;">promise</a> <a href="/blog/tags/react/" style="font-size: 16.67px;">react</a> <a href="/blog/tags/sort/" style="font-size: 10px;">sort</a> <a href="/blog/tags/string/" style="font-size: 10px;">string</a> <a href="/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/blog/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 10px;">日常</a> <a href="/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/blog/tags/%E9%97%AD%E5%8C%85/" style="font-size: 10px;">闭包</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/04/16/vscode-config/">vscode-config</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/30/qian-duan-jian-kong/">前端监控</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/27/qian-duan-gong-cheng-hua/">前端工程化</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/26/xing-neng-you-hua/">性能优化</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/24/http-and-https-and-tlsssl/">HTTP &amp; HTTPS &amp; TLS/SSL</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>