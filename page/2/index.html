<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://cumbermiao.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://cumbermiao.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue-ssr-ti-yan" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/07/vue-ssr-ti-yan/" class="article-date">
  <time datetime="2020-03-07T17:02:00.000Z" itemprop="datePublished">2020-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/07/vue-ssr-ti-yan/">Vue SSR 体验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>client-side ， server-side</li>
<li>webpack 配置</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2020/03/07/vue-ssr-ti-yan/" data-id="ck940dc2s00110knw7hmv4s78" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mian-shi" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/03/05/mian-shi/" class="article-date">
  <time datetime="2020-03-05T16:55:43.000Z" itemprop="datePublished">2020-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/03/05/mian-shi/">记今年面试的感受</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>去年开始关注招聘， 准备找一份薪资高一点的工作， 断断续续也面了几家， 本来是抱着比较高的薪资要求去面试的， 结果都没有达到期望， 一度怀疑自己值不值这个价。 后来还是去了一家做政府运维的公司， 即使薪资没有达到期望。<br>当时来这家面试的时候是周六， 来的时候感觉整个园区的环境不错， 也比较安静， 就对这家起了好意。结果入职没几天， 跟周围的同事交流了一下， 发现整个公司的研发氛围不是很好， 而且人事那边跟我聊得一些奖金都没有， 加上后来又逼着整个研发部门签996的协议， 我决定还是重新换家公司吧。<br>就这样一直到了今年， 由于疫情的影响， 招聘的职位较往年少了很多。当时在家比较中意的是字节跳动的岗位， 也一直在看面试题， 结果三面发挥失常就挂了，为此还失落了好几天。按照我现在的情况， 这次的工作一定要去知名的公司了， 不然后面的发展会比较受限。<br>跟这边的公司提了离职之后， 也一直帮这家公司在面试前端， 当时面到一些技术上感觉并不是非常厉害的人薪资都还挺高。我不知道是自己时运不济还是自己技术不够厉害， 说实话我面的那些前端技术深度而言都没有我好。也没办法， 只好继续投简历， 我把能投的一些知名公司基本都投了一遍， 当时技术面试都感觉不错， 结果都没后续了。我找了其中一家 hr 问了原因， hr 给的回复是可能基础有点弱。我只能苦笑。<br>再结合我面试的候选人，说实话， 你的技术并不是唯一的判断标准， 我觉得就我面试的几家公司而言，没有说我技术基础不行的， 有可能是技术方向不对口， 他又缺对应的人， 所以遇到其他对口的候选人我就没有什么竞争力了。但是更多的是 hr 方面， 所以简历一定需要做好， 突出自己的优点， 能吹的尽量吹， 不然即使技术面过了， hr 那边还有其他候选人， 如果你学历突出， 那就突出你的技术， 你的成就。<br>最后总结一句， 不是技术 leader 直面的情况， 或者说面试没有突出到自己的亮点， 能够让 leader 指定要你的情况， hr 最终选择的依据就是你的简历， 所以一定突出自己简历上的亮点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2020/03/05/mian-shi/" data-id="ck940dc2b000i0knwep1r7g29" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-zai-jquery-zhong-shi-yong-vue-he-react-de-zu-jian-hua-si-xiang" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/28/zai-jquery-zhong-shi-yong-vue-he-react-de-zu-jian-hua-si-xiang/" class="article-date">
  <time datetime="2020-02-28T13:56:22.000Z" itemprop="datePublished">2020-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/28/zai-jquery-zhong-shi-yong-vue-he-react-de-zu-jian-hua-si-xiang/">在 jquery 中使用 vue 和 react 的组件化思想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近遇到一个比较奇葩的场景， 业务需求没有描述清楚导致原来逻辑全部被修改。实际需求只是增加一个类型， 在选择该类型时展示的 UI 和需要提交的表单元素都要修改。<br>当时在看代码时， 代码已经达到了一千多行， 对于一个页面来说还是比较多的。而且又需要快速恢复之前的逻辑并且加上现有的需求， 我一直在考虑有没有一个好的模式能够简单实现需求。<br>最终， 我尝试了使用类似 vue 和 react 组件的方法来实现。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>首先理一下业务需求：<br>实现新增编辑和查看一个表单， 在新增时有一个升舱类型3， 其对应的值为 1,2,3 ,其中 1,2 与 3 所对应的视图不一样， 具体体现在  1,2 会有座位表格信息， 3 没有座位表格信息， 1,2 的价格表格信息与 3 展现的字段不一致， 最大的区别在于 1,2 对于国内航线和国际航线可以一起提交， 3 只能选择一种航线类型。</p>
<p>当时的思路就是设计一个模式， 可以兼容现在的类型以及之前的类型并且可以最小改动现状的代码。当时想使用类似 vue 和 react 这种数据驱动的方式， 在 state 中定义 upgfType 变量表示 升舱类型， 根据 upgfType 不同的值， 使用不同的 UI 。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="methods-amp-hooks-函数代理"><a href="#methods-amp-hooks-函数代理" class="headerlink" title="methods &amp; hooks 函数代理"></a>methods &amp; hooks 函数代理</h4><p>为了拥有类似 vue 的开发体验， 我对 methods 以及 hooks 中的函数进行了 this 绑定， 绑定在 ==组件对象模型==上， 此处需要区分组件和组件模型的概念。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有组件对象需要调用该函数，否则 this 指向错误</span></span><br><span class="line"><span class="keyword">var</span> BindThisInMethodsHooks = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> methods = <span class="built_in">Object</span>.keys(obj.methods);</span><br><span class="line">    <span class="keyword">var</span> hooks = <span class="built_in">Object</span>.keys(obj.hooks);</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; methods.length) &#123;</span><br><span class="line">        <span class="keyword">var</span> methodName = methods[i];</span><br><span class="line">        obj.methods[methodName] = obj.methods[methodName].bind(obj);</span><br><span class="line">        proxyMethod(methodName, obj);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; hooks.length) &#123;</span><br><span class="line">        <span class="keyword">var</span> hookName = hooks[i];</span><br><span class="line">        obj.hooks[hookName] = obj.hooks[hookName].bind(obj);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记以及Bind 过 this</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">"_bind"</span>, &#123;</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyMethod = <span class="function"><span class="keyword">function</span>(<span class="params">methodName, obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, methodName, &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> obj.methods[methodName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码中还在组件模型对象上添加了一个属性 <code>_bind</code> 用来表示该组件模型对象以及调用过 <code>BindThisInMethodsHooks</code> 绑定过 this 。 如果重复调用的话， 会报重复使用 Object.defineProperty 定义属性的错误。</p>
<h4 id="组件模型对象"><a href="#组件模型对象" class="headerlink" title="组件模型对象"></a>组件模型对象</h4><p>定义的具体组件模型如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> emptyObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Base = &#123;</span><br><span class="line">      el: <span class="string">""</span>, <span class="comment">// 挂载的 dom 节点</span></span><br><span class="line">      template: <span class="string">""</span>, <span class="comment">//html 字符串</span></span><br><span class="line">      instance: <span class="literal">undefined</span>, <span class="comment">// Component 实例</span></span><br><span class="line">      state: emptyObj,</span><br><span class="line">      props: emptyObj, <span class="comment">//未使用</span></span><br><span class="line">      methods: emptyObj,</span><br><span class="line">      hooks: &#123;</span><br><span class="line">          beforeCreate: noop, <span class="comment">//调用 http 初始化数据的地方</span></span><br><span class="line">          created: noop, <span class="comment">//根据数据渲染 template 的地方, 此处需要将 template 渲染完成</span></span><br><span class="line">          mounted: noop, <span class="comment">//组件已挂载， 此处用来监听事件</span></span><br><span class="line">          beforeUpdate: noop, <span class="comment">//组件更新前， 用于 state 改变之后， template 中结构发生变化， 卸载 mounted 中监听的事件</span></span><br><span class="line">          updated: noop, <span class="comment">// 组件state UI 已经更新， 用于 template 结构变化后， 重新监听事件</span></span><br><span class="line">          beforeDestory: noop, <span class="comment">//卸载之前, 此处用来卸载事件</span></span><br><span class="line">          destoryed: noop <span class="comment">//组件已卸载</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>  当时在定义 hooks 即生命周期时， 首先关注的就是 <code>beforeCreate</code> , <code>created</code>, <code>mounted</code>, <code>beforeDestory</code>。<br>   与 vue 不同，<code>beforeCreate</code> 生命周期我是用来获取渲染数据的， 实际场景中就是发送 http 请求， 这样使用有一个坏处： 如果你在 <code>beforeCreate</code> 中的请求时间较长， 那么后面的 hooks 无法执行， 导致初始 UI 长时间空白。    </p>
<p>   <code>created</code> 周期我是用来渲染数据至 template 中的， 此周期生成展示在页面上的 html 字符串。</p>
<p>  <code>mounted</code> 周期是在 html 已经插入到 el 上， 此时我们可能需要监听一些事件， 例如在业务中点击国内航线需要展示国内航线的表格， 点击国际航线需要展示国际航线的表格。以及需要使用 bootstrap-table  生成价格信息或者座位信息表格。</p>
<p>  <code>beforeDestory</code> 周期主要是用来卸载监听的事件， 此处比较繁琐的是你在 mounted 所有的监听事件回调都需要使用具名函数， 否则此处你无法卸载。</p>
<p>  以上三个周期看似够用， 但实际上在你需要更新 UI 时就相形见绌了。例如， 原本的升舱类型为 1， 此时我改变为 3， 就需要重新生成表单。<br>重新生成 UI 那么就要卸载之前 UI 的监听， 此处使用 <code>beforeUpdate</code> 周期来做这种事。<br>同样在重新生成 UI 且挂载后你需要为当前 UI 添加事件监听， 可以在 <code>updated</code>周期中处理。</p>
<p>在以上描述中， 我们可以看到从 <code>mounted</code> 到 <code>updated</code> 的过程中需要处理很多的事件监听以及卸载。而在 Vue 中， 由于有自己的 template 模板， 以及 @ 的事件监听指令，它可以集中处理事件的监听和卸载， 不需要  coder 自己手动卸载。 当然， Vue 也提供了自己的合成事件来减轻 coder 自己的负担。<br>Vue 有了 template 模板之后， 他还可以做一件事， 拆分子组件。 在 template 解析到 options.components 一样的标签时， 它知道这是一个子组件， 从而去初始化子组件。而在我的实现中 template 是 html 字符串， 没有解析 template 的过程， 也就无法实现子组件， 没有子组件那么在根据 state 更新 UI 时， 就需要 coder 自己手动去处理事件的卸载与监听。 如果有子组件， 这些完全可以在子组件的 hooks 中实现， 当前组件的代码就会清晰很多。</p>
<h4 id="组件类"><a href="#组件类" class="headerlink" title="组件类"></a>组件类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj._bind) &#123;</span><br><span class="line">          BindThisInMethodsHooks(obj);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.fiber = obj;</span><br><span class="line">      <span class="keyword">this</span>.fiber.initState = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.fiber.state);</span><br><span class="line">      <span class="keyword">this</span>.fiber.instance = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">var</span> deferred = <span class="keyword">this</span>.fiber.hooks.beforeCreate();</span><br><span class="line">      <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">          deferred</span><br><span class="line">              .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                  _this.render();</span><br><span class="line">                  _this.fiber.hooks.mounted();</span><br><span class="line">              &#125;)</span><br><span class="line">              .fail(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          _this.render();</span><br><span class="line">          _this.fiber.hooks.mounted();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Component.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fiber.hooks.created();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"=========render========="</span>);</span><br><span class="line">      <span class="keyword">var</span> $el = $(<span class="keyword">this</span>.fiber.el);</span><br><span class="line">      $el.html(<span class="keyword">this</span>.fiber.template);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Component.prototype.rerender = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"=========rerender========="</span>);</span><br><span class="line">      <span class="keyword">this</span>.fiber.template = <span class="keyword">this</span>.fiber.initTemplate;</span><br><span class="line">      <span class="keyword">this</span>.fiber.hooks.created();</span><br><span class="line">      <span class="keyword">this</span>.fiber.hooks.beforeUpdate();</span><br><span class="line">      <span class="keyword">var</span> $el = $(<span class="keyword">this</span>.fiber.el);</span><br><span class="line">      $el.html(<span class="keyword">this</span>.fiber.template);</span><br><span class="line">      <span class="keyword">this</span>.fiber.hooks.updated();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Component.prototype.destory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fiber.hooks.beforeDestory();</span><br><span class="line">      $(<span class="keyword">this</span>.fiber.el).html(<span class="string">""</span>);</span><br><span class="line">      <span class="keyword">this</span>.fiber.hooks.destoryed();</span><br><span class="line">      <span class="keyword">this</span>.fiber.state = <span class="keyword">this</span>.fiber.initState;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.fiber.initState;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>  compnent 类的实现就相对简单， 其主要目的是按照顺序执行组件模型中的 hooks ， 并且提供 rerender 和 destory 方法。<br>  以上代码中， 用到了 jquery 中 defer 对象， 确保 <code>beforeCreate</code> 中的异步数据请求到之后再渲染 template 。<br>  提供 rerender 方法的主要原因是没有实现根据 state 里面的状态变更自动更新， 因为有些情况下 state 里面的数据更新之后并不需要更新页面， 所以 rerender 就留给 coder 自己去实现哪些 state 更新之后去冲渲染。例如本例中需要更加 upgfType 自动更新 UI。<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> editModal;</span><br><span class="line">    $(<span class="string">"#exampleModal"</span>).on(<span class="string">"shown.bs.modal"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"relatedTarget"</span>, e.relatedTarget);</span><br><span class="line">        <span class="keyword">if</span> (e.relatedTarget === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            formModal.state.isEdit = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        editModal = <span class="keyword">new</span> Component(formModal);</span><br><span class="line">        <span class="keyword">var</span> state = editModal.fiber.state;</span><br><span class="line">        <span class="keyword">var</span> upgfType = state.upgfType;</span><br><span class="line">        <span class="keyword">var</span> airlineType = state.airlineType;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(state, &#123;</span><br><span class="line">            upgfType: &#123;</span><br><span class="line">                <span class="keyword">get</span>: function() &#123;</span><br><span class="line">                    <span class="keyword">return</span> upgfType;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>: function(newVal) &#123;</span><br><span class="line">                    upgfType = newVal;</span><br><span class="line">                    editModal.rerender();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            airlineType: &#123;</span><br><span class="line">                <span class="keyword">get</span>: function() &#123;</span><br><span class="line">                    <span class="keyword">return</span> airlineType;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>: function(newV) &#123;</span><br><span class="line">                    airlineType = newV;</span><br><span class="line">                    <span class="keyword">if</span> (state.upgfType === <span class="string">"3"</span>) &#123;</span><br><span class="line">                        editModal.rerender();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次实践组件化的过程， 对 vue 的生命周期有了更深的体验， 当然也明白了 react 为什么要出 hooks 原因。后面如果有机会可以借助开源的 template 库自己实现子组件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2020/02/28/zai-jquery-zhong-shi-yong-vue-he-react-de-zu-jian-hua-si-xiang/" data-id="ck940dc3b00250knwb9tj92ac" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-arrayprototypesort-dui-zi-fu-chuan-pai-xu-de-wen-ti" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/22/js-arrayprototypesort-dui-zi-fu-chuan-pai-xu-de-wen-ti/" class="article-date">
  <time datetime="2020-02-22T11:44:27.000Z" itemprop="datePublished">2020-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/22/js-arrayprototypesort-dui-zi-fu-chuan-pai-xu-de-wen-ti/">JS Array.prototype.sort 对字符串排序的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天刷 leetcode 中遇到一个场景需要对字符数组进行排序， 书写是按照之前常用的写法 <code>arr.sort((a,b)=&gt;a-b)</code> , 但是其排序结果跟未排序之前一样。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><strong>sort 语法</strong>：<code>arr.sort([compareFunction])</code>。<br><code>compareFunction</code> 参数可选，其作用是按照指定的某种顺序进行排列。如果省略， 元素按照==转换为的字符串的各个字符的 Unicode 位点进行排序==。<br>其中 <code>compareFunction</code>还接受两个参数<code>firstEle</code>表示第一个用于比较的元素， <code>secondEle</code>表示第二个比较的元素。<br><strong>sort 返回值</strong> : 原地排序后的数组。  </p>
<h2 id="实际结果"><a href="#实际结果" class="headerlink" title="实际结果"></a>实际结果</h2><blockquote>
<p>从上述描述中可知，<code>sort</code>如果不指定 <code>compareFunction</code> 比较函数， 本就会将元素转成字符串并比较 Unicode 编码大小。<br>按照上面的结论，解决起因中的问题直接去掉 <code>compareFunction</code> 即可, 实际结果也是对的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'f'</span>,<span class="string">'c'</span>].sort();</span><br><span class="line"><span class="comment">//['a','b','c','f']</span></span><br></pre></td></tr></table></figure>
<p>再分析下我其中代码的逻辑, 在 <code>(a,b)=&gt;a-b</code> 中我期望按照升序的方式排序， 由于 a,b 是字符，所以我期望 <code>a-b</code> 计算两者的 Unicode 编码，但实际上结果是 <code>NaN</code>。<br>这实际上是与比较操作符的规则弄混了， 对于比较操作符如果两个操作符是字符串时，比较的是其 Unicode 编码， 对于 <code>-</code> 操作符如果有一个操作符是字符串， 会先调用 <code>Number()</code> 方法将其转成数字类型进行比较， 而对于非数字的字符串<code>Number()</code>转换后的结果都是 <code>NaN</code>。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><code>sort</code> 方法如果不提供 <code>compareFunction</code> 参数，默认会将元素转成字符串，比较其 Unicode 编码大小。<br><code>arr.sort((a,b)=&gt;a-b)</code> 在比较字符串时， 根据 <code>-</code>操作符的规则， 会先调用 <code>Number()</code>, 对于无法转换成数字的字符结果为 <code>NaN</code>, 最终排序后数组不会改变。想要获得预期结果，可以利<strong>比较操作符</strong>的规则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b)<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>-</code> 操作符的转换规则：</p>
<ul>
<li>如果有一个操作数是 NaN，则结果是 NaN； </li>
<li>如果是 Infinity 减 Infinity，或者 -Infinity 减-Infinity ，则结果是 NaN； </li>
<li>如果是 Infinity 减-Infinity，则结果是 Infinity； </li>
<li>如果是-Infinity 减 Infinity，则结果是-Infinity； </li>
<li>如果有一个操作数是字符串、布尔值、 null 或 undefined，则先在后台调用 Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN； </li>
<li>如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法并将得到的字符串转换为数值。 </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2020/02/22/js-arrayprototypesort-dui-zi-fu-chuan-pai-xu-de-wen-ti/" data-id="ck940dc28000d0knwf3fbhc35" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Array/" rel="tag">Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/js/" rel="tag">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/sort/" rel="tag">sort</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/string/" rel="tag">string</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-fiber-zhi-ji-chu-gai-nian" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/16/react-fiber-zhi-ji-chu-gai-nian/" class="article-date">
  <time datetime="2020-02-16T15:30:17.000Z" itemprop="datePublished">2020-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/16/react-fiber-zhi-ji-chu-gai-nian/">React Fiber 基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>React 在 15.x 版本对其核心的 reconciler 的算法进行了重构， 由此产生了 Fiber。 Fiber 解决了 React 现在存在的性能问题，使得 React 能更好的处理 state 更新和 UI 更新。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16deecd21336ca41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="fiber前后"></p>
<p>之前版本的 React reconcilation 对于更新任务无法中断， 如果更新任务长时间占用主线程则会发生卡顿，无法响应用户交互。<br>React 16 对 reconcilation 进行了重构， 将 DOM 更新拆分成一个个小任务， 且每个任务有各自的优先级， 高优先级的任务可以中断低优先级的任务。  </p>
<p><strong>Fiber 的核心思想就是协程以及合作调度模式， 其 fiberNode 的数据结构以及使用链表模拟函数调用栈(call stack) 都是为了实现合作调度。</strong></p>
<h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><blockquote>
<p>Fiber 原意为协程， 协程的特点在于允许执行被挂起与被恢复，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。<br>我们知道 CPU 的最小的分配单位为进程，最小的调度单位为线程， JS engine 是基于单线程的。以 chrome 来说， 一个 tab 页会有一个 renderer process 来负责这个 tab 页的事物处理。其中 js 线程 和 UI 渲染的线程是互斥的， 两者只能有一个同时执行。正常来说我们无法介入 renderer process 的主线程的调度，而通过协程我们则可以做到。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> task</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (task = tasks.shift()) &#123;</span><br><span class="line">    <span class="comment">// 🔴 判断是否有高优先级事件需要处理, 有的话让出控制权</span></span><br><span class="line">    <span class="keyword">if</span> (hasHighPriorityEvent()) &#123;</span><br><span class="line">      <span class="keyword">yield</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完高优先级事件后，恢复函数调用栈，继续执行...</span></span><br><span class="line">    execute(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合作调度模式"><a href="#合作调度模式" class="headerlink" title="合作调度模式"></a>合作调度模式</h2><blockquote>
<p>把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行。 </p>
</blockquote>
<p>合作式调度主要就是用来分配任务的，当有更新任务来的时候，不会马上去做 Diff 操作，而是先把当前的更新送入一个 Update Queue 中，然后交给 Scheduler 去处理，Scheduler 会根据当前主线程的使用情况去处理这次 Update。为了实现这种特性，使用了requestIdelCallbackAPI。</p>
<h2 id="requestIdelCallback"><a href="#requestIdelCallback" class="headerlink" title="requestIdelCallback"></a>requestIdelCallback</h2><blockquote>
<p>requestIdelCallback 是浏览器提供的一个 api ， 使用其包裹的函数会在浏览器每帧的空余时间执行。</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/9981C9BF2B7741CAB26BB59AE94F097F?method=download&shareKey=d59ea04f63e30e62343b0688891c0785" alt="renderer process"></p>
<h2 id="FiberNode"><a href="#FiberNode" class="headerlink" title="FiberNode"></a>FiberNode</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FiberNode</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  tag: WorkTag,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: mixed,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: null | string,</span></span></span><br><span class="line"><span class="function"><span class="params">  mode: TypeOfMode,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Instance</span></span><br><span class="line">  <span class="keyword">this</span>.tag = tag; <span class="comment">//定义fiber的类型。它在reconcile算法中用于确定需要完成的工作。如前所述，工作取决于React元素的类型，函数createFiberFromTypeAndProps将React元素映射到相应的fiber节点类型。在我们的应用程序中，ClickCounter组件的属性标记是1，表示ClassComponent，而span元素的属性标记是5，表示Host Component。</span></span><br><span class="line">  <span class="keyword">this</span>.key = key; <span class="comment">//具有一组children的唯一标识符，可帮助React确定哪些项已更改，已添加或从列表中删除。它与此处描述的React的“list and key”功能有关。</span></span><br><span class="line">  <span class="keyword">this</span>.elementType = <span class="literal">null</span>; <span class="comment">//调试过程中发现该值与 type 一样， 暂不知道具体作用。</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="literal">null</span>; <span class="comment">//定义与此fiber关联的功能或类。对于类组件，它指向构造函数；对于DOM元素，它指定HTML tag。可以使用这个字段来理解fiber节点与哪个元素相关。</span></span><br><span class="line">  <span class="keyword">this</span>.stateNode = <span class="literal">null</span>; <span class="comment">//保存对组件的类实例，DOM节点或与fiber节点关联的其他React元素类型的引用。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fiber</span></span><br><span class="line">  <span class="keyword">this</span>.return = <span class="literal">null</span>; <span class="comment">//父节点的 fiberNode</span></span><br><span class="line">  <span class="keyword">this</span>.child = <span class="literal">null</span>; <span class="comment">//子节点的 fiberNode</span></span><br><span class="line">  <span class="keyword">this</span>.sibling = <span class="literal">null</span>; <span class="comment">//兄弟节点的 fiberNode</span></span><br><span class="line">  <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.ref = <span class="literal">null</span>; <span class="comment">//&#123;current&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.pendingProps = pendingProps; <span class="comment">//已从React元素中的新数据更新，并且需要应用于子组件或DOM元素的props</span></span><br><span class="line">  <span class="keyword">this</span>.memoizedProps = <span class="literal">null</span>; <span class="comment">//在前一次渲染期间用于创建输出的props</span></span><br><span class="line">  <span class="keyword">this</span>.updateQueue = <span class="literal">null</span>; <span class="comment">//用于状态更新，回调函数，DOM更新的队列</span></span><br><span class="line">  <span class="keyword">this</span>.memoizedState = <span class="literal">null</span>; <span class="comment">//于创建输出的fiber状态。处理更新时，它会反映当前在屏幕上呈现的状态。</span></span><br><span class="line">  <span class="keyword">this</span>.dependencies = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.mode = mode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effects</span></span><br><span class="line">  <span class="keyword">this</span>.effectTag = NoEffect;</span><br><span class="line">  <span class="keyword">this</span>.nextEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.firstEffect = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.lastEffect = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.expirationTime = NoWork;</span><br><span class="line">  <span class="keyword">this</span>.childExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.alternate = <span class="literal">null</span>; <span class="comment">//current 与 alternate 相互引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16deecc6db5530be?imageslim" alt="fiber 链表"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/10/21/16deecca7850a24d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="fiber 迭代顺序"></p>
<p><strong>使用链表模拟函数调用栈更为可控，fiber 节点的处理可以随时中断和恢复， 对于处理过程中发生异常的节点， 我们可以根据 return 回溯打印出完整的’节点栈’。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2020/02/16/react-fiber-zhi-ji-chu-gai-nian/" data-id="ck940dc2j000r0knwekwlda3o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/fiber/" rel="tag">fiber</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/js/" rel="tag">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/react/" rel="tag">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js-zhong-bi-bao-de-ying-yong" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/13/js-zhong-bi-bao-de-ying-yong/" class="article-date">
  <time datetime="2020-02-13T12:22:20.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/13/js-zhong-bi-bao-de-ying-yong/">JS 中闭包的应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>闭包是 JS 中非常常用的手段， 本篇文章根据闭包的特点来总结其日常应用。</p>
</blockquote>
<h2 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h2><blockquote>
<p>闭包是词法作用域和书写代码所产生的自然结果， 其表现形式在于函数在其定义以外的词法环境执行，但是函数仍然能够访问其定义的词法环境。 简单来说，外层函数执行之后返回内部函数， 内部函数在其它词法环境执行时仍然能够访问外层函数中所定义的变量。</p>
</blockquote>
<p>就如上概念所说， 闭包最主要的特点就是能够访问外层函数的变量， 下面就根据该特点来分析其应用。</p>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><!-- 
TODO: 模块化
### 模块化的前身
> js 早期是没有模块化的概念， 而使用闭包可以解决全局变量污染的问题。

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  a = ()</span><br><span class="line"><span class="string">``</span><span class="string">` --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 请求的并发控制</span></span><br><span class="line"><span class="string">&gt; 我们知道， 浏览器的 http 请求是有并发限制的， 过多的 http 请求会占用过多的浏览器资源， 所以并发控制是常用的场景。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">实现一个  maxFetch 函数,  使用 fetch 请求， 不考虑 fetch 的具体实现。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">generateMaxFetch</span>(<span class="params">max=<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> urls = []</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parcelFetch</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(urls.length&amp;&amp;max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> url = urls.shift()</span><br><span class="line">        max--;</span><br><span class="line">        mockFetch(url).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(res)</span><br><span class="line">          max++;</span><br><span class="line">          parcelFetch()</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">      urls.push(url)</span><br><span class="line">      parcelFetch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> maxFetch = generateMaxFetch(<span class="number">3</span>)</span><br><span class="line">  maxFetch(<span class="string">'/111'</span>)</span><br><span class="line">  maxFetch(<span class="string">'/222'</span>)</span><br><span class="line">  maxFetch(<span class="string">'/333'</span>)</span><br><span class="line">  maxFetch(<span class="string">'/444'</span>)</span><br><span class="line">  maxFetch(<span class="string">'/555'</span>)</span><br><span class="line">  maxFetch(<span class="string">'/666'</span>)</span><br><span class="line">  maxFetch(<span class="string">'/777'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p>在一些业务场景中需要保证全局只有一个实例对象， 如登录框等， 借助闭包很容易实现。<br>假设 artDialog 有 init 方法用来初始化弹框， hide 方法隐藏登录框， show 方法显示弹框, 实现一个全局唯一的登录框。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loginDialog = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>)instance = artDialog.init();</span><br><span class="line">        instance.show()</span><br><span class="line">        <span class="keyword">return</span>  instance.hide</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hideLogin = loginDialog();</span><br><span class="line">hideLogin();</span><br></pre></td></tr></table></figure>

<h3 id="debounce-amp-throttle"><a href="#debounce-amp-throttle" class="headerlink" title="debounce &amp; throttle"></a>debounce &amp; throttle</h3><blockquote>
<p>对于用户可能频繁触发的事件，我们可以使用防抖或者节流的方式来优化性能。<br>实现节流和防抖， 注意要保持用户最后一次触发事件的结果的一致性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer)clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            fn.apply(<span class="literal">null</span>,<span class="built_in">arguments</span>)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">fn, duration</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canRun = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">var</span> lastFn = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> wrap = <span class="function"><span class="keyword">function</span>(<span class="params">fn,args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(canRun)&#123;</span><br><span class="line">          canRun = <span class="literal">false</span></span><br><span class="line">          fn.apply(<span class="keyword">this</span>,args&amp;&amp;[...args])</span><br><span class="line">          timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            canRun = <span class="literal">true</span>;</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            lastFn&amp;&amp;wrap(lastFn)</span><br><span class="line">            lastFn = <span class="literal">null</span></span><br><span class="line">          &#125;,duration)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          lastFn = fn.bind(<span class="keyword">this</span>,...args)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="built_in">arguments</span></span><br><span class="line">        wrap(fn,args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h3><blockquote>
<p>柯里化函数允许函数的参数分多次传递， 其中也使用了闭包。</p>
</blockquote>
<h4 id="闭包的错误使用"><a href="#闭包的错误使用" class="headerlink" title="闭包的错误使用"></a>闭包的错误使用</h4><p>在之前实现柯里化函数错误使用了闭包， 具体实现如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//考虑参数中带有占位符 _</span></span><br><span class="line">    <span class="keyword">const</span> _ = &#123; <span class="attr">type</span>: <span class="string">'@@/placeholder'</span> &#125;</span><br><span class="line">    <span class="keyword">const</span> isPlaceholder = <span class="function"><span class="params">arg</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">'[object Object]'</span> &amp;&amp; arg === _;</span><br><span class="line">    <span class="keyword">const</span> hasPlaceholder = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.some.call(args, item =&gt; isPlaceholder(item))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> paramsIsReady = <span class="function">(<span class="params">params, expectedLen</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(params.length &gt;= expectedLen)</span></span><br><span class="line">      <span class="comment">// console.log(hasPlaceholder(params))</span></span><br><span class="line">      <span class="keyword">return</span> params.length &gt;= expectedLen &amp;&amp; !hasPlaceholder(params)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> insertParam = <span class="function">(<span class="params">params, insert</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasPlaceholder(params)) <span class="keyword">return</span> params.concat(insert)</span><br><span class="line">      <span class="keyword">const</span> res = params.slice(<span class="number">0</span>)</span><br><span class="line">      <span class="keyword">let</span> idx = <span class="number">0</span>, param = <span class="built_in">Array</span>.isArray(insert) ? insert.shift() : insert</span><br><span class="line">      <span class="keyword">while</span> (idx &lt; res.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPlaceholder(res[idx])) &#123;</span><br><span class="line">          idx++</span><br><span class="line">          <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        res[idx]=param</span><br><span class="line">        param = <span class="built_in">Array</span>.isArray(insert) ? insert.shift() : <span class="literal">undefined</span></span><br><span class="line">        idx++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(insert)&amp;&amp;insert.length)&#123;res = res.concat(insert)&#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">curry2</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> params = <span class="keyword">new</span> <span class="built_in">Array</span>(fn.length).fill(_)</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        params = insertParam(params,args)</span><br><span class="line">        <span class="comment">// console.log(paramsIsReady(params,fn.length))</span></span><br><span class="line">        <span class="keyword">if</span> (paramsIsReady(params,fn.length)) &#123;</span><br><span class="line">          <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, params)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> recursive</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上代码问题在于 curry2 中的 params ,  上面写法的问题在于同一个经过 curry2 处理过后的函数都能访问到同一个 params， 具体查看下面的测试用例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x,y,z</span>)=&gt;</span><span class="keyword">return</span> x+y+z</span><br><span class="line"><span class="keyword">const</span> curSum = curry2(sum)</span><br><span class="line"><span class="keyword">let</span> a = curSum(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> b = curSum(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(b(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>如以上代码所示， 其中 a,b 访问的都是 curSum 中的 params ， 所以最终的输出结果必然与期望不一致。 </p>
<h4 id="修复错误闭包问题"><a href="#修复错误闭包问题" class="headerlink" title="修复错误闭包问题"></a>修复错误闭包问题</h4><blockquote>
<p>要解决以上问题也是很简单， 只要将 fn 函数所需要的的参数都放入到返回的 recursive 中即可。 </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry2</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (paramsIsReady(args, fn.length)) &#123;</span><br><span class="line">          <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...restArgs</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> params = insertParam(args,restArgs)</span><br><span class="line">            <span class="keyword">return</span> recursive(...params)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>闭包作为 js 中重要手段， 其使用也是千变万化， 以上只是简单总结了几个常用的场景， 后面遇到其他闭包的场景也会持续更新。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2020/02/13/js-zhong-bi-bao-de-ying-yong/" data-id="ck940dc29000e0knw3mvmhq3c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/js/" rel="tag">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E9%97%AD%E5%8C%85/" rel="tag">闭包</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-new-array-yu-map-de-wen-ti" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/02/13/new-array-yu-map-de-wen-ti/" class="article-date">
  <time datetime="2020-02-13T09:44:52.000Z" itemprop="datePublished">2020-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/02/13/new-array-yu-map-de-wen-ti/">new Array 与 map 的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天在写代码时， 想生成一个元素为1~n的数组，当时的操作是这样子的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eles = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">9</span>)</span><br><span class="line">eles.map(<span class="function">(<span class="params">item,idx</span>)=&gt;</span>idx+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果 eles 数组并没有如期望的 [1,2…9] ,而仍是 [empty,empty,…] , 随后我就使用 <code>eles.map((item,idx)=&gt;console.log(idx))</code> 来查看 map 中的回调是否调用， 结果是没有调用。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>遇到这个奇怪的问题， 我查看了 MDN 中 map 的描述， 发现其中有这么一段：</p>
<blockquote>
<p>callback is invoked only for indexes of the array which have assigned values (including undefined).    </p>
</blockquote>
<p>callback 函数只会在有值的索引上被调用，具体不被调用的情况如下：</p>
<ul>
<li>没有设置索引</li>
<li>索引被删除</li>
<li>索引上未设值<br>MDN 上对符合以上条件的数组称为 <em>稀疏数组</em></li>
</ul>
<h2 id="实际结果"><a href="#实际结果" class="headerlink" title="实际结果"></a>实际结果</h2><blockquote>
<p>按照以上的说明，我进行了以下的用例测试。</p>
</blockquote>
<ol>
<li>使用 <code>new Array</code> 创建空数组， 结果 callback 未调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eles = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">9</span>)</span><br><span class="line">eles.map((<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">console</span>.log(item))</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>[,,,]</code> 创建空数组， 结果 callback 未调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eles = [,,,]</span><br><span class="line">eles.map((<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">console</span>.log(item))</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>[undefined,undefined,undefined]</code> 创建数组， 结果 callback 调用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eles = [<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>]</span><br><span class="line">eles.map((<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">console</span>.log(item))</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>[,undefined,undefined]</code> 创建数组， 结果不为 empty 的元素被调用 callback。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eles = [,<span class="literal">undefined</span>,<span class="literal">undefined</span>]</span><br><span class="line">eles.map((<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">console</span>.log(item))</span><br><span class="line"><span class="comment">//undefined *2</span></span><br></pre></td></tr></table></figure></li>
<li>使用 <code>delete</code> 删除元素, 被删除索引的值变为 empty， 该索引不会调用 callback。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eles = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">delete</span> eles[<span class="number">0</span>]</span><br><span class="line">eles.map((<span class="function"><span class="params">item</span>=&gt;</span><span class="built_in">console</span>.log(item))</span><br><span class="line"><span class="comment">//2,3</span></span><br></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote>
<p>如同上面描述所说 map 方法对于稀疏数组中元素为 empty 的不会调用 callback。   </p>
</blockquote>
</li>
</ol>
<p>与 map 表现一致的的数组方法还有： <code>every</code> , <code>filter</code>, <code>flat</code>, <code>flatMap</code>, <code>forEach</code>, <code>reduce</code>, <code>reduceRight</code>, <code>some</code>。</p>
<p>会对所有元素调用的数组方法有： <code>find</code>, <code>findIndex</code>。</p>
<p>对于有需要初始化数组元素可以使用 <code>fill</code> 方法， 或者使用 <code>Array.apply(null,Array(9))</code> 的方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2020/02/13/new-array-yu-map-de-wen-ti/" data-id="ck940dc2d000l0knw9fk1hunl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Array/" rel="tag">Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Sparse-Array/" rel="tag">Sparse Array</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/js/" rel="tag">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-process-thread-in-browser" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/11/12/process-thread-in-browser/" class="article-date">
  <time datetime="2019-11-12T16:03:47.000Z" itemprop="datePublished">2019-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/11/12/process-thread-in-browser/">浏览器的进程与线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- UNDONE: 参考文章中有些地方矛盾， html parse 和 style calc 是否同步执行？ main thread 的详细过程？  是否存在 paint 步骤还是直接调用 compositor thread -->
<p><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part2" target="_blank" rel="noopener">inside browser 系列</a></p>
<p><a href="https://aerotwist.com/blog/the-anatomy-of-a-frame/" target="_blank" rel="noopener">Frame 解析</a></p>
<p><a href="https://medium.com/@francesco_rizzi/javascript-main-thread-dissected-43c85fce7e23" target="_blank" rel="noopener">js 主线程</a>, 在阅读此文章前需要阅读 <a href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" target="_blank" rel="noopener">event loop</a> ,了解下相关概念。</p>
<p><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">可以部分参考</a></p>
<p><a href="https://frarizzi.science/journal/web-engineering/browser-rendering-queue-in-depth" target="_blank" rel="noopener">页面绘制流程</a></p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><blockquote>
<p>牢记一个进程可以由多个线程组成。<br>进程是 cpu 资源分配的最小单位，可以拥有内存和独立运行的最小单位。 可以理解为一个工厂。</p>
</blockquote>
<p>线程是 cpu 调度的最小单位， 即给工厂打工的工人。 cpu 可以调度工人给工厂工作，  且同一个工厂的工厂在同一块区域，即共享资源。</p>
<h2 id="浏览器的多进程"><a href="#浏览器的多进程" class="headerlink" title="浏览器的多进程"></a>浏览器的多进程</h2><blockquote>
<p>浏览器是基于多进程的， 每个 tab 页或者插件都是一个单独的进程， 除此之外还有主进程、 GPU 进程等，此处只解释主要的几个进程。</p>
</blockquote>
<ul>
<li><p>browser 进程： 该进程是浏览器的主进程，处理除了 tab 页之外的功能， 如：地址栏、标签、前进后退、网络资源管理等。</p>
</li>
<li><p>renderer 进程: 默认每个 tab 页面一个进程， 负责该 tab 页所有展示的内容。</p>
</li>
<li><p>GPU 进程： 用于处理 GPU 任务。</p>
</li>
<li><p>plugin 进程： 处理插件相关的任务， 如 flash </p>
</li>
<li><p>extension 进程： 处理谷歌插件的任务。</p>
</li>
</ul>
<p>chrome 浏览器对每个 tab 页都申请一个单独的 render process ， 好处在于某个 tab 的 render process 崩溃时不会影响其他的 tab 页， 甚至 chrome 现在对每个 iframe 都申请了一个 render process。<br>坏处就在于 tab 页一多， 那么浏览器就会占据较大的内存资源。</p>
<p>browser process 拥有 UI thread 用于绘制 button 等元素， network thread 用于请求资源， storage thread 控制文件读写权限。</p>
<h2 id="简单分析一个简单请求的过程"><a href="#简单分析一个简单请求的过程" class="headerlink" title="简单分析一个简单请求的过程"></a>简单分析一个简单请求的过程</h2><p>从浏览器地址栏输入 url ， 浏览器请求获取数据并且展示在页面上， 这个过程调用了哪些线程？</p>
<p>首先当你输入 url 的时候， UI thread 会判断这个是一个 搜索问题还是一个 url ， 如果是搜索问题则请求搜索引擎否则请求 url。</p>
<p>确认之后，  UI thread 会发起一个网络请求， 此时 network thread 会使用对应的协议建立请求。此时， netowrk thread 可能会收到 301 中状态码， 此时会告诉 UI thread 资源被重定向， UI thread 重新发起请求。</p>
<p>network thread 得到响应之后会根据响应数据的类型进行不同的处理， 如果响应的数据是 html 文件， network thread 会将 html 数据传递给 renderer process 。如果是 zip 文件这种就会传递数据给下载管理器。如果不符合浏览器的安全策略，如发生了跨域此时就会报错，不需要调用 renderer process。</p>
<p>如果 network thread 认为浏览器需要跳转至对应的页面， 它会告诉 UI thread 数据已经准备好， UI thread 会找一个 renderer process 并传递数据。<br>在 network thread 请求数据的同时， UI thread 就已经开始请求 renderer process 了， 在 network thread 告诉 UI thread 数据已经获取时， renderer process 已经待命了。</p>
<p>由于 UI thread 是属于 browser process 的， 与 renderer process 通信需要通过 IPC ， 使用 stream 的方式传递 html 数据。 一旦 browser process 接收到 renderer process 已经 commit 的确认之后结束导航阶段， 开始文档加载阶段。<br>此时，地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中。。</p>
<p>当 renderer process 渲染页面结束之后， 它会通过 IPC 通知 browser process 结束loading，此处也是 onload 事件发生的地方。</p>
<p>至此，整个流程结束。</p>
<h2 id="renderer-process"><a href="#renderer-process" class="headerlink" title="renderer process"></a>renderer process</h2><blockquote>
<p>renderer process 负责对应 tab 页的渲染， 一般会包含 a main thread, a raster thread, a compositor thread, 如果使用了 web worker 或者 service worker ， 还会有 worker threads .</p>
</blockquote>
<p><img src="https://note.youdao.com/yws/api/personal/file/9981C9BF2B7741CAB26BB59AE94F097F?method=download&shareKey=d59ea04f63e30e62343b0688891c0785" alt="threads in renderer"></p>
<p>上图展示了一帧的步骤， 有的步骤不是每帧都会执行。</p>
<h3 id="renderer-process-处理过程"><a href="#renderer-process-处理过程" class="headerlink" title="renderer process 处理过程"></a>renderer process 处理过程</h3><ol>
<li><p>renderer process 在接收 html 数据时， main thread 将 html 字符串解析成 DOM。</p>
</li>
<li><p>如果在解析 html 元素时遇到了 img、link 标签时，preload scanner 会在 html 解析器解析到 tokens 时， 就告诉 browser process 的 network thread 请求对应资源。</p>
</li>
<li><p>如果 html 解析器遇到了 script 标签， main thread 会停止解析 html ， 去加载解析并执行 js 代码。 因为 js 可能会改变 DOM 结构，如果 js 改变了 DOM 结构，那么就需要在 js 之后重新构成 DOM 结构。对于不改变 DOM 结构的 js 我们可以使用 defer 或者 async 属性。</p>
</li>
<li><p>main thread 解析 css ， 计算每个 node 节点的样式。</p>
</li>
<li><p>通过遍历 DOM 和每个元素的样式计算， 会得出 DOM 树和 css 树。</p>
</li>
<li><p>使用 DOM 树和 css 树生成 layout 树， layout 树与 DOM 树类似，但是不包含 display:none 这种不展示的元素。</p>
</li>
<li><p>即使知道了不同元素的位置及样式信息，我们还需要知道不同元素的绘制先后顺序才能正确绘制出整个页面。在绘制阶段，主线程会遍历布局树以创建绘制记录。绘制记录可以看做是记录各元素绘制先后顺序的笔记。</p>
</li>
<li><p>在获取了所有需要的信息之后， 浏览器使用合成技术来绘制每帧。<br>合成技术会将一个页面分割成不同的层， 并对每层进行光栅化， 最终在 compositor thread 中重新组合。<br>在分层时， main thread 会遍历 layout 树创建 layer 树(即 update layer tree)。 添加了 <code>will-change</code> CSS 属性的元素，会被看做单独的一层。</p>
</li>
</ol>
<p>一旦 layer 树被创建，渲染顺序被确定，主线程会把这些信息通知给 compositor thread， compositor thread 会栅格化每一层。有的层的可以达到整个页面的大小，因此，合成器线程将它们分成多个磁贴，并将每个磁贴发送到 raster threads，raster threads 会栅格化每一个磁贴并存储在 GPU 显存中。</p>
<p>一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧。</p>
<p>compositor thread 随后会通过 IPC 消息传递给 browser process ，由于浏览器的 UI 改变或者其它插件的渲染进程也可以添加合成帧，这些合成帧会被传递给 GPU 用以展示在屏幕上，如果滚动发生，合成器线程会创建另一个合成帧发送给 GPU。</p>
<p>合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/4C8C97130D784A1987586082011C5353?method=download&shareKey=5e3499aeca6993c1c53826196026c818" alt="main thread"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2019/11/12/process-thread-in-browser/" data-id="ck940dc2e000m0knwe5cobh89" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webpack-split-chunk" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/09/11/webpack-split-chunk/" class="article-date">
  <time datetime="2019-09-11T16:03:47.000Z" itemprop="datePublished">2019-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/09/11/webpack-split-chunk/">记一次webpack拆包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近部门对买家vo管理系统准备使用 react + webpack 进行工程化管理和重构， 本次开发的新功能账期便直接上了， 主要用了 react + react-router-dom + antd 。<br>在最终打包的时候遇到了一个问题： 使用 splitChunk 将 node_modules 中的三方包全部拆分到一个 vendor chunk 里面体积较大， 达到了 1.34m 。<br>分析了打包结构之后， 发现 antd 占了很大比重， 想到以后开发其他模块也是基于 antd 于是就决定将 antd 单独拆分出来， 其他的 react 等三方库还是放在同一个chunk里。</p>
<p>以下是 splitChunk 配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">splitChunks: &#123;</span><br><span class="line">  cacheGroups: &#123;</span><br><span class="line">    vendor: &#123;</span><br><span class="line">        test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        chunks: <span class="string">'initial'</span>,</span><br><span class="line">        name: <span class="function">(<span class="params"><span class="built_in">module</span></span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> packageName = <span class="built_in">module</span>.context.match(<span class="regexp">/[\\/]node_modules[\\/](.*?)([\\/]|$)/</span>)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(packageName.match(<span class="regexp">/(ant\-design|antd)/</span>))<span class="keyword">return</span> <span class="string">'common-ui'</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'common'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置会将 ant-design 和 ant 的模块拆分到 common-ui 里面， 其中 css 也需要单独提取出来，需要注意打包的文件名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">  filename: <span class="string">'[name]/[name].css'</span>,</span><br><span class="line">  chunkFilename: <span class="string">'[name]/[name].css'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终拆分的目录结构如下：<br>common        common.js common.css<br>common-ui     common-ui.js common-ui.css<br>credit        credit.js credit.css</p>
<p>由于对 antd 的主题进行了定制， 最终打出来的样式文件 credit.css 好像包含了 antd 中的样式， 后面还需要对其进行优化。</p>
<p>随着各个模块的不断加入， 开发时候的热更新肯定会越来越慢， 到时候需要使用 dll 进行优化， 对于打包速度到时候看情况， 对于一些三方模块可以使用开发时候的缓存，不再重新打包减少打包时长。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上打包只是固定拆分了 antd 库， 其中在实践过程中遇到了一些问题。</p>
<p>由于需要定制主题， 所以使用 ant.less 改变了主题颜色， 如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ant.less</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"~antd/dist/antd.less"</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">@primary-color:</span> <span class="number">#1470CC</span>; <span class="comment">// 全局主色</span></span><br><span class="line"><span class="variable">@link-color:</span> <span class="number">#1470CC</span>; <span class="comment">// 链接色</span></span><br><span class="line"><span class="variable">@success-color:</span> <span class="number">#00b300</span>; <span class="comment">// 成功色</span></span><br><span class="line"><span class="variable">@warning-color:</span> <span class="number">#FF7733</span>; <span class="comment">// 警告色</span></span><br><span class="line"><span class="variable">@error-color:</span> <span class="number">#E64545</span>; <span class="comment">// 错误色</span></span><br><span class="line"><span class="variable">@font-size-base:</span> <span class="number">14px</span>; <span class="comment">// 主字号</span></span><br><span class="line"><span class="variable">@heading-color:</span><span class="number">#222</span>; <span class="comment">// 标题色</span></span><br><span class="line"><span class="variable">@text-color:</span> <span class="number">#555</span>; <span class="comment">// 主文本色</span></span><br><span class="line"><span class="variable">@text-color-secondary:</span><span class="number">#888</span>; <span class="comment">// 次文本色</span></span><br><span class="line"><span class="variable">@disabled-color :</span> <span class="number">#b3b3b3</span>; <span class="comment">// 失效色</span></span><br><span class="line"><span class="variable">@border-radius-base:</span> <span class="number">6px</span>; <span class="comment">// 组件/浮层圆角</span></span><br><span class="line"><span class="variable">@border-color-base:</span> <span class="number">#ced3d9</span>; <span class="comment">// 边框色</span></span><br><span class="line"><span class="variable">@box-shadow-base:</span> none; <span class="comment">// 浮层阴影</span></span><br></pre></td></tr></table></figure>

<p>在多页中引入 ant.less 和 各自的样式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//page1</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'ant.less'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'index.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//page2</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'ant.less'</span>;</span><br></pre></td></tr></table></figure>
<p>不知道是由于 scss 的原因， 使用以上写法打包之后 page1.css 和 page2.css 中还是包含了 ant 的样式， 虽然 common-ui 也提取了 ant 的样式。</p>
<p>最终还是改了写法， ant 中只定义覆盖主题的变量， 在 js 中引入 antd.less， 如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.less'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'ant.less'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'index.scss'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//page2</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.less'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'ant.less'</span>;</span><br></pre></td></tr></table></figure>

<p>以上只是对 antd 提取， 在多页中还有通用组件， 如果组件较多也需要进行提取。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2019/09/11/webpack-split-chunk/" data-id="ck940dc2u00140knw5l4t4xwk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ssh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/06/21/ssh/" class="article-date">
  <time datetime="2019-06-21T10:28:45.000Z" itemprop="datePublished">2019-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/06/21/ssh/">ssh命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>SSH 是一种通用的、功能强大的、基于软件的网络安全性解决方案。<br>术语：</p>
<ul>
<li>SSH 泛指SSH协议或者产品名为SSH的产品</li>
<li>SSH-1 SSH 协议版本1 ， SSH-1 SSH 协议版本2</li>
<li>SSH1 实现SSH-1协议的软件 ， SSH2 实现SSH-2协议的软件</li>
<li>ssh 运行安全终端回话和远程命令的客户端程序</li>
<li>OpenSSHift openBSD项目的产品，同时实现了 SSH-1协议和SSH-2协议。</li>
</ul>
<h3 id="ssh-登录远程"><a href="#ssh-登录远程" class="headerlink" title="ssh 登录远程"></a>ssh 登录远程</h3><p>使用 user 用户登录到 <a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -l user www.test.com</span><br></pre></td></tr></table></figure>
<p>也可以使用 user@host 代替 -l 选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@www.test.com</span><br></pre></td></tr></table></figure>

<h3 id="scp-传输文件"><a href="#scp-传输文件" class="headerlink" title="scp 传输文件"></a>scp 传输文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp sourcefile destination</span><br></pre></td></tr></table></figure>
<p>例如将远程中的文件拷贝到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp user@www.test.com:readme readme</span><br></pre></td></tr></table></figure>

<h3 id="known-host"><a href="#known-host" class="headerlink" title="known host"></a>known host</h3><p>ssh 客户端首次碰到一个新远程主机时需要执行一些额外的工作并显示和下面类似的消息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -l user www.test.com</span><br><span class="line">Host key not found from the list of known hosts.</span><br><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<h3 id="生成秘钥对"><a href="#生成秘钥对" class="headerlink" title="生成秘钥对"></a>生成秘钥对</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<h3 id="ssh-代理"><a href="#ssh-代理" class="headerlink" title="ssh 代理"></a>ssh 代理</h3><p>用户每次使用公钥认证运行 ssh 或者 scp 命令都需要重新输入口令， 这种反复输入口令的操作会让人很反感， 为了只需要一次认证就可以让 ssh 和 scp 记住你的身份直到用户退出， ssh 代理就提供了这个功能。</p>
<p>代理是一个程序，他可以把私钥保存在内存中， 并使用其来为 SSH客户端提供认证服务。如果用户在登录回话时启动了一个代理，那么以后的认证都不需要再重新输入密码， 知道用户结束代理为止。这个代理程序就是 ssh-agent 。</p>
<p>将秘钥装入到代理中，可以使用 <code>ssh-add id_rsa</code> , 查看代理中的所有秘钥 <code>ssh-add -l</code> , 从代理中卸载一个秘钥 <code>ssh-add -d id_rsa</code> , 卸载代理中的所有秘钥 <code>ssh-add -D</code> .</p>
<h3 id="代理转发"><a href="#代理转发" class="headerlink" title="代理转发"></a>代理转发</h3><p>当我们从本地执行命令 <code>scp user@www.test1.com:readme user@www.test2.com:readme</code> 复制文件时会失败。<br>当用户在本地机器运行 scp 命令时， 他连接到 <a href="http://www.test1.com" target="_blank" rel="noopener">www.test1.com</a> 并间接调用了另一个 scp 命令执行拷贝工作 ， 第二个 scp 命令也会要求秘钥出入口令， 由于远程主机上没有终端回话提示， 导致执行失败。 S<br>SH代理可以解决以上问题， 第二个 scp 命令只需要查询用户本地的 SSH 代理， 这样就不需要输入口令了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://cumbermiao.github.io/blog/2019/06/21/ssh/" data-id="ck940dc2o000w0knwhul2fzyg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/">&amp;laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Array/" rel="tag">Array</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/Sparse-Array/" rel="tag">Sparse Array</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/diff/" rel="tag">diff</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/fiber/" rel="tag">fiber</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/hooks/" rel="tag">hooks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/promise/" rel="tag">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/react/" rel="tag">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/sort/" rel="tag">sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/string/" rel="tag">string</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E9%97%AD%E5%8C%85/" rel="tag">闭包</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Array/" style="font-size: 13.33px;">Array</a> <a href="/blog/tags/Sparse-Array/" style="font-size: 10px;">Sparse Array</a> <a href="/blog/tags/diff/" style="font-size: 10px;">diff</a> <a href="/blog/tags/fiber/" style="font-size: 10px;">fiber</a> <a href="/blog/tags/git/" style="font-size: 10px;">git</a> <a href="/blog/tags/hooks/" style="font-size: 10px;">hooks</a> <a href="/blog/tags/js/" style="font-size: 20px;">js</a> <a href="/blog/tags/promise/" style="font-size: 10px;">promise</a> <a href="/blog/tags/react/" style="font-size: 16.67px;">react</a> <a href="/blog/tags/sort/" style="font-size: 10px;">sort</a> <a href="/blog/tags/string/" style="font-size: 10px;">string</a> <a href="/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/blog/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 10px;">日常</a> <a href="/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/blog/tags/%E9%97%AD%E5%8C%85/" style="font-size: 10px;">闭包</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2020/04/17/vscode-config/">vscode-config</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/30/qian-duan-jian-kong/">前端监控</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/27/qian-duan-gong-cheng-hua/">前端工程化</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/26/xing-neng-you-hua/">性能优化</a>
          </li>
        
          <li>
            <a href="/blog/2020/03/24/http-and-https-and-tlsssl/">HTTP &amp; HTTPS &amp; TLS/SSL</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>